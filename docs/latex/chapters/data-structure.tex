\chapter{Code structure}

I created three Gradle projects, backend and frontend (which I'll call layers), and common. When building the application, the common code is compiled into both layers. This allows knowledge of the required data classes without the need for the layers to directly import one another,they can be distributed as completely separate packages. 

\section{The database}

I chose SQLite as my database engine. It's lightweight, decently fast, and self-contained. The theory is that the file may be used like a writeable game save in the future, as making deep copies is only limited by disk space and I/O speed. This is the main difference when compared to a traditional SQL server. The engine adds no redundancy -- small amounts of data loss are not a problem as rebuilding the database is very quick. However, for transactions, the standard ACID (atomicity, consistency, isolation, durability) principles are followed. Exposed provides a DSL-specific transaction block, which runs all contained code in a database context, automatically dropping changes if any errors are raised.

The database is created when loading a new PBF dataset, and can be read unlimited times until a new file is presented. The program spawns a PBF iterator from the osm4j library and reads every element. Nodes and ways are read unconditionally, as relations must reference them to hold any meaningful data. Out of every category, elements with the \verb|highway| or \verb|building| tag are collected, their child elements retrieved and dumped into the database. After this process, the on-CPU storage object is purposefully thrown away due to the high number of unused nodes.

I ended up going with a very simple data structure of just two tables, Buildings and Roads. Both tables have osm\_id, tags and ways columns, and buildings include additional information about their location, OSM element type, as well as a capacity, calculated as a function of their area and height. Some buildings have a "height" tag that's specified in meters, or a "levels" tag counting its floors. If none of these is present, I calculate the value as if there was only one floor. Capacity is used by the random selection algorithm while simulating to weigh the options. Roads are stored as simple splines of one or more serialised ways, with their separate tags also stored (if they have any). This does not encode width information as per OSM standards.

The OSM tags take up the most space in the database, as they're simple strings that can't meaningfully be encoded. Since the key-value pairs are unique most of the time, I found no real gains in creating a foreign key structure for them and instead used a JSON serialiser. Later editions of the software could have a hybrid solution: a lookup table for common values, and simple string storage for all others.



\subsection{Data access}

Database communication is handled by the DatabaseAccess singleton. All methods are independent of the engine being used, so the database string could be swapped for any other scheme supported by Exposed. Queries are serialisable transactions, which mostly prevents reading incomplete buildings or roads. There is a simple helper function to take an in-memory storage object and simply overwrite the database with it, to be used when a new PBF file is loaded. Kotlin natively supports Sequences, a list type that can produce items while it's being iterated. I made use of this to send building data to the socket in smaller chunks, before the whole transaction is done. If the transaction block would ever freeze, incomplete data may be sent, but the program does not crash.


\section{Common classes}

I made the following utility classes in the common project. \begin{itemize}
    \item \textbf{SerializeableNode/Way/Tag} -- Data classes explicitly annotated as @Serializable for Ktor, they wrap the respective osm4j types. Tags are serialised as "key=value" strings.
    \item \textbf{Vec3} -- A three-dimensional vector class with Doubles instead of Floats and basic arithmetic methods. These are used throughout the program to maintain higher precision when using real-world coordinates.
    \item \textbf{Building, Road} -- The runtime equivalents of the database tables of the same name. The frontend can't see the database structure, only these representations. They also function as Data Access Objects (DAOs) for Exposed.
    \item \textbf{Agent} -- A person in the city and simulation. They have a preset speed and age group, as well as location information.
    \item \textbf{ObservableMap} -- A typical Kotlin MutableMap, extended with callbacks for any changes that occur (for example, adding an item).
    \item \textbf{ControlMessage (and inheriting classes)} -- A simple explicitly serialisable class with predefined fields; this is how I ensured that every websocket message contained the expected data
\end{itemize}

\label{serialise}
Exposed supports custom columns, which was used to convert the vectors to a VARCHAR\footnote{variable length character array, it can store arbitrary text up to its length limit, only using the necessary number of bytes} type in SQL. This is type-safe when reading or writing, conversion happens automatically.
\begin{lstlisting}[caption=Custom column type in JetBrains Exposed]
    object Vec3ColumnType : ColumnType<Vec3>() {
    override fun sqlType(): String = "VARCHAR(50)"
    override fun valueFromDB(value: Any): Vec3 {
        return when (value) {
            is String -> Vec3.fromString(value)
            else -> ...}} ... }
\end{lstlisting}