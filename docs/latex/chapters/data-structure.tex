\chapter{Code structure}

I created three Gradle projects, backend and frontend (which I'll call layers), and common. When building the application, the common code is compiled into both layers. This allows knowledge of the required data classes without the need for the layers to directly import one another,they can be distributed as completely separate packages.

\section{Network communication}
The application was built in such a way that any current and future communication between the server and client can be made using an RFC 6455-compliant\cite{RFC6455} WebSocket provided by the server. This allows asynchronous, thread-safe communication between the two parties without being bound by packet timing. This approach also supports a "multiple clients, single server" architecture.

\subsection{Websocket usage}
Websocket communication is usually started by a client pinging a target address, where a server resides. The initiating message is a handshake that must contain the host, port, resource name, and a flag showing whether the connection is secure. Secure connections must also include a TLS handshake. If the server replies, a TCP connection is established -- a two-way tunnel for sending further messages with low delay. The connection has a set of possible states.

Two important rules came up during the project: there can only ever be one "connecting" socket between any given pair of machines, and sockets may fail. The latter requires a periodically retrying the connection. It's worth to keep in mind that a failed socket may drop data. If the link breaks, text in transit will not be re-sent. "Connecting" sockets are not yet ready for data, but usually don't need manual overrides, as a badly configured socket will eventually fail.

Each packet, called a frame in this context, may be a data frame or a control frame. Control frames include "ping", "pong" and "close". Data frames may can be used to transit text or binary data. The main noticeable difference from a standard TCP endpoint is the URI scheme: "ws://" in this case. Arbitrary data may be serialised~(see \ref{serialise}) to a data interchange format, such as JSON (JavaScript Object Notation) or YAML (Yet Another Markup Language). As text is highly compressible, a surprising amount of in-memory information can be transmitted in a short space of time.

Websockets have several advantages: they're connections that are easy to keep alive, they don't require manual pinging and may transfer data in large batches. Setup is also easy, as any language with a relevant library can be used to create a socket. They're slightly slower than a simple TCP connection, as the overhead is non-insignificant; it's not a problem for this particular project, though.

I chose websockets because I wanted guarantees for the validity of data, but I did not care for the ordering or timing of data arriving. The protocol strikes a good balance between these properties. I also wanted to try something different from the classic call-and-response using fulfilled promises. Decoupling messages also supports using asynchronous structures.

\subsection{Ktor-specific solutions}

In Ktor, a socket server is created by overriding the \verb|Application.configureRouting()| method. An endpoint can be made by using "webSocket" instead of "get" or "post"; in my case, it's available at \verb|ws://host:port/control|. The appropriate plugin must also be installed from code and can be configured here; options include the timeout and ping periods, or the content converter can be set. I used Json with serialised class discriminators to send custom control messages. These are simple data classes in a two-level inheritance hierarchy, and replace string input validation by only accepting the required data types.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=150mm, keepaspectratio]{images/control-messages.png}
    \caption{The main page of the app, with a "false 3D" view}
\end{figure}

The endpoint has an implicit "incoming" attribute. This is a Kotlin ReceiveChannel, which is coroutine-based and helps avoid busy waiting\footnote{constantly retrying an operation (\eg~getting data from a usually empty container), this is generally wasteful} by suspending the current program flow until a message can actually be retrieved. Sending a response is done by calling \verb|sendSerialized()|, which puts data into the "outgoing" SendChannel. As long as the socket is kept open using pings, any number of messages may be sent.


The SocketServer/SocketClient classes are responsible for the actual connections, they're treated as singletons. When a message is received on either end, a map of type-function pairs (functions are first class citizens in Kotlin) is queried, and the corresponding operation is run using a coroutine, provided it is listed. This flaunts the Open-Closed Principle in object.oriented programming, defined by Bertrand Meyer\cite{OOSC-OCP} as follows: \say{Modules should be both open and closed. [\ldots] A module is said to be closed if it is available for use by other modules. This assumes that the module has been given a well-defined, stable description.} While the message class itself is open to extension, any modification requires changing the list of callback functions. I found this to be an acceptable trade-off, as it gives compile time protection against typos, missing fields and the processing of unknown messages.
The server side keeps a list of all connected clients and treats them as subscribers, sending every response to all of them; one backend instance can service multiple clients.

\label{file-upload}
The client may send a protocol buffer file through the \verb|/pbf_file| POST endpoint to overwrite the current database with a different region of the globe. Data is loaded as described in section~\ref{pbf-loading}.

\section{The database}

I chose SQLite as my database engine. It's lightweight, decently fast, and self-contained. The theory is that the file may be used like a writeable game save in the future, as making deep copies is only limited by disk space and I/O speed. Traditional SQL server data is split among many files, making them unsuitable. The engine has no automatic backups -- small amounts of data loss are not a problem as rebuilding the database is very quick. For transactions, the standard ACID (atomicity, consistency, isolation, durability) principles are followed. Exposed provides a DSL-specific transaction block, which runs all contained code in a database context, automatically dropping changes if any errors are raised.

\label{pbf-loading}
The database is created when loading a new PBF dataset, and can be read unlimited times until a new file is presented. The program spawns a PBF iterator from the osm4j library and reads every element into an OsmStorage object. Nodes and ways are read unconditionally, as relations must reference them to hold any meaningful data. Out of every category, elements with the \verb|highway| or \verb|building| tag are collected, their child elements retrieved and dumped into the database. After this process, the on-CPU storage object is purposefully thrown away and cleaned up due to the high number of unused nodes.

I ended up going with a very simple data structure of just two tables, Buildings and Roads. Both tables have osm\_id, tags and ways columns, and buildings include additional information about their location, OSM element type, as well as a capacity, calculated as a function of their area and height. Some buildings have a "height" tag that's specified in meters, or a "levels" tag counting its floors. If none of these is present, I calculate the value as if there was only one floor. Capacity is used by the random selection algorithm while simulating to weigh the options. Roads are stored as simple splines of one or more serialised ways, with their separate tags also stored (if they have any). This does not encode width information as per OSM standards.

The OSM tags take up the most space in the database, as they're simple strings that can't meaningfully be encoded. Since the key-value pairs are unique most of the time, I found no real gains in creating a foreign key structure for them and instead used a JSON serialiser. Later editions of the software could have a hybrid solution: a lookup table for common values, and simple string storage for all others.

\subsection{Data access}

Database communication is handled by the DatabaseAccess singleton. All methods are independent of the engine being used, so the database string could be swapped for any other scheme supported by Exposed. Queries are serialisable transactions, which mostly prevents reading incomplete buildings or roads. Kotlin natively supports Sequences, a list type that can produce items while it's being iterated. I made use of this to send building data to the socket in smaller chunks, before the whole transaction is done. If the transaction block would ever freeze, incomplete data may be sent, but the program does not crash.

\section{Common classes}

I made the following utility classes in the common project. \begin{itemize}
    \item \textbf{SerializeableNode/Way/Tag} -- Data classes explicitly annotated as @Serializable for Ktor, they wrap the respective osm4j types. Tags are expressed as "key=value" strings.
    \item \textbf{Vec3} -- A three-dimensional vector class with Doubles instead of Floats and basic arithmetic methods. These are used throughout the program to maintain higher precision when using real-world coordinates.
    \item \textbf{Building, Road} -- The runtime equivalents of the database tables of the same name. The frontend can't see the database structure, only these representations. They also function as Data Access Objects (DAOs) for Exposed.
    \item \textbf{Agent} -- A person in the city and simulation. They have a pre-set speed and age group, as well as location information.
    \item \textbf{ObservableMap} -- A typical Kotlin MutableMap, extended with callbacks for any changes that occur (for example, adding an item).
    \item \textbf{ControlMessage (and inheriting classes)} -- A simple explicitly serialisable class with predefined fields; this is how I ensured that every websocket message contained the expected data
\end{itemize}

\label{serialise}
Exposed supports custom columns, which was used to convert the vectors to a VARCHAR\footnote{variable length character array, it can store arbitrary text up to its length limit, only using the necessary number of bytes} type in SQL. This is type-safe when reading or writing, conversion happens automatically.
\begin{lstlisting}[caption=Custom column type in JetBrains Exposed]
    object Vec3ColumnType : ColumnType<Vec3>() {
    override fun sqlType(): String = "VARCHAR(50)"
    override fun valueFromDB(value: Any): Vec3 {
        return when (value) {
            is String -> Vec3.fromString(value)
            else -> ...}} ... }
\end{lstlisting}

\section{The frontend}
The client project takes a slightly more monolithic approach. It's a libGDX application, where the main scene 


