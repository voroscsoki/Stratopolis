\chapter{Network communications}
The application was built in such a way that any current and future communication between the server and client can be made using an RFC 6455-compliant\cite{RFC6455} WebSocket provided by the server. This allows asynchronous, thread-safe communication between the two parties without being bound by packet timing. This approach also supports a "multiple clients, single server" architecture.

\section{Websocket usage}
Websocket communication is usually started by a client pinging a target address, where a server resides. The initiating message is a handshake that must contain the host, port, resource name, and a flag showing whether the connection is secure. Secure connections must also include a TLS handshake. If the server replies, a TCP connection is established -- a two-way tunnel for sending further messages with low delay. The connection has a set of possible states.

Two important rules came up during the project: there can only ever be one "connecting" socket between any given pair of machines, and sockets may fail. The latter requires a periodically retrying the connection. It's worth to keep in mind that a failed socket may drop data. If the link breaks, text in transit will not be re-sent. "Connecting" sockets are not yet ready for data, but usually don't need manual overrides, as a badly configured socket will eventually fail.

Each packet, called a frame in this context, may be a data frame or a control frame. Control frames include "ping", "pong" and "close". Data frames may can be used to transit text or binary data. The main noticeable difference from a standard TCP endpoint is the URI scheme: "ws://" in this case. Arbitrary data may be serialised~(see \ref{serialise}) to a data interchange format, such as JSON (JavaScript Object Notation) or YAML (Yet Another Markup Language). As text is highly compressible, a surprising amount of in-memory information can be transmitted in a short space of time.

Websockets have several advantages: they're connections that are easy to keep alive, they don't require manual pinging and may transfer data in large batches. Setup is also easy, as any language with a relevant library can be used to create a socket. They're slightly slower than a simple TCP connection, as the overhead is non-insignificant; this is not a problem for this particular project, though.

I chose websockets because I wanted guarantees for the validity of data, but I did not care for the ordering or timing of data arriving. The protocol strikes a good balance between these properties. I also wanted to try something different from the classic call-and-response using fulfilled promises. Decoupling messages also supports using asynchronous structures.

\section{Ktor-specific solutions}

In Ktor, a socket server is created by overriding the \verb|Application.configureRouting()| method. An endpoint can be made by using "webSocket" instead of "get" or "post". The appropriate plugin must also be installed from code and can be configured here. For example, the timeout and ping period, or the content converter can be set. I used Json with serialised class discriminators so the control messages from section \ref{control-messages} can be transmitted in a type-safe manner. The socket is created at \verb|ws://host:port/control|.

The endpoint then gets an implicit "incoming" attribute. This is a Kotlin-specific ReceiveChannel, which is coroutine-based and helps avoid busy waiting\footnote{constantly retrying an operation (\eg~getting data from a usually empty container), this is generally wasteful} by suspending the current program flow until a message can actually be retrieved. Decoding the string to the concrete type (used for handling) is then done by the Json plugin, using the discriminator. Sending a response is done similarly, by calling \verb|sendSerialized()|, which puts data into the "outgoing" SendChannel. As long as the channel is kept open using pings, this process can be repeated.

When a message is received on either end, a map of type-function pairs (functions are first class citizens in Kotlin) is queried, and the corresponding operation is run using a coroutine, provided it is listed. This flaunts the Open-Closed Principle in object.oriented programming, defined by Bertrand Meyer\cite{OOSC-OCP} as follows: \say{Modules should be both open and closed. [\ldots] A module is said to be closed if it is available for use by other modules. This assumes that the module has been given a well-defined, stable description.} While the message class itself is open to extension, any modification requires changing the list of callback functions. I found this to be an acceptable trade-off, as it gives compile time protection against typos, missing fields and the processing of unknown messages. The server side also keeps a list of all connected clients and treats them as subscribers, sending every response to all of them; one backend instance can server multiple clients.

\label{file-upload}
The client may send a protocol buffer file through the \verb|/pbf_file| POST endpoint to overwrite the current database with a different region of the globe. Data is loaded as described in section~\ref{pbf-loading}.